package main

import (
	"flag"
	"fmt"
	"os"
	"regexp"
	"text/template"

	"github.com/goccy/go-yaml"
)

// safePattern validates that region fields contain only safe characters
// (alphanumeric, hyphens, and underscores) to prevent YAML injection.
var safePattern = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

// RegionConfig represents a single region configuration from regions.yaml.
type RegionConfig struct {
	ID   string `yaml:"id"`
	Name string `yaml:"name"`
	Tag  string `yaml:"tag"`
}

// RegionsConfig represents the full regions.yaml structure.
type RegionsConfig struct {
	Regions []RegionConfig `yaml:"regions"`
}

// TemplateData holds the data passed to the GoReleaser template.
type TemplateData struct {
	Regions []RegionConfig
}

const goreleaserTemplate = `# Generated by tools/generate-goreleaser - DO NOT EDIT MANUALLY
# Regenerate with: make generate-goreleaser

version: 2

builds:
{{- range .Regions}}
  - id: {{.Name}}
    main: ./cmd/pulumicost-plugin-aws-public
    binary: pulumicost-plugin-aws-public-{{.Name}}
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    tags:
      - {{.Tag}}
    ldflags:
      - -s -w -X main.version={{"{{"}} .Version {{"}}"}}
{{end}}
archives:
  - formats:
      - tar.gz
    name_template: >-
      {{"{{"}} .ProjectName {{"}}"}}_
      {{"{{"}} .Version {{"}}"}}_
      {{"{{"}} title .Os {{"}}"}}_
      {{"{{"}} if eq .Arch "amd64" {{"}}"}}x86_64
      {{"{{"}} else if eq .Arch "386" {{"}}"}}i386
      {{"{{"}} else {{"}}"}}{{"{{"}} .Arch {{"}}"}}{{"{{"}} end {{"}}"}}
      {{"{{"}} if .Arm {{"}}"}}v{{"{{"}} .Arm {{"}}"}}{{"{{"}} end {{"}}"}}
    format_overrides:
      - goos: windows
        formats:
          - zip

checksum:
  name_template: checksums.txt

snapshot:
  name_template: "{{"{{"}} incpatch .Version {{"}}"}}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"
      - "chore:"
      - "Merge pull request"
      - "Merge branch"

source:
  enabled: false
`

// main parses command-line flags, reads and validates a regions YAML file,
// generates a GoReleaser configuration from the regions, and writes it to disk.
//
// It accepts flags `-config` (path to regions YAML, default "regions.yaml")
// and `-output` (output file path, default ".goreleaser.yaml"). The program
// exits with status 1 on errors loading the config, validating regions, or
// generating the output file, and prints a confirmation message on success.
func main() {
	configPath := flag.String("config", "regions.yaml", "Path to regions config")
	outputPath := flag.String("output", ".goreleaser.yaml", "Output file path")
	flag.Parse()

	// Load regions config
	regions, err := loadRegionsConfig(*configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading regions config: %v\n", err)
		os.Exit(1)
	}

	// Validate regions
	if err := validateRegions(regions); err != nil {
		fmt.Fprintf(os.Stderr, "Validation error: %v\n", err)
		os.Exit(1)
	}

	// Generate GoReleaser config
	if err := generateGoReleaserConfig(regions, *outputPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating GoReleaser config: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated GoReleaser config at %s with %d regions\n", *outputPath, len(regions))
}

// loadRegionsConfig reads a YAML file at filename and returns the parsed slice of RegionConfig entries.
// It returns an error if the file cannot be read or if the YAML cannot be unmarshaled into RegionsConfig.
func loadRegionsConfig(filename string) ([]RegionConfig, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var config RegionsConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	return config.Regions, nil
}

// validateRegions verifies that each RegionConfig has a non-empty ID, Name, and Tag,
// that the Tag equals "region_"+ID, that no two regions share the same ID, and that
// all values contain only safe characters (alphanumeric, hyphens, underscores) to
// prevent YAML injection attacks.
// It returns an error describing the first validation failure, or nil if all regions are valid.
func validateRegions(regions []RegionConfig) error {
	seen := make(map[string]bool)
	for _, r := range regions {
		if r.ID == "" {
			return fmt.Errorf("region missing id")
		}
		if r.Name == "" {
			return fmt.Errorf("region %s missing name", r.ID)
		}
		if r.Tag == "" {
			return fmt.Errorf("region %s missing tag", r.ID)
		}
		// Validate characters to prevent YAML injection
		if !safePattern.MatchString(r.ID) {
			return fmt.Errorf("region id %q contains invalid characters (only alphanumeric, hyphens, underscores allowed)", r.ID)
		}
		if !safePattern.MatchString(r.Name) {
			return fmt.Errorf("region name %q contains invalid characters (only alphanumeric, hyphens, underscores allowed)", r.Name)
		}
		if !safePattern.MatchString(r.Tag) {
			return fmt.Errorf("region tag %q contains invalid characters (only alphanumeric, hyphens, underscores allowed)", r.Tag)
		}
		expectedTag := "region_" + r.ID
		if r.Tag != expectedTag {
			return fmt.Errorf("region %s tag mismatch: expected %s, got %s", r.ID, expectedTag, r.Tag)
		}
		if seen[r.ID] {
			return fmt.Errorf("duplicate region id: %s", r.ID)
		}
		seen[r.ID] = true
	}
	return nil
}

// generateGoReleaserConfig generates a GoReleaser configuration file at outputPath using the provided regions.
// It fills a TemplateData with the regions, parses the package's goreleaserTemplate, and writes the rendered result
// to the specified output file.
//
// regions is the list of RegionConfig entries to include in the generated configuration.
// outputPath is the filesystem path where the rendered configuration will be created (truncated if existing).
//
// It returns an error if template parsing fails, the output file cannot be created, template execution fails,
// or if closing the output file produces an error.
func generateGoReleaserConfig(regions []RegionConfig, outputPath string) (err error) {
	data := TemplateData{
		Regions: regions,
	}

	tmpl, err := template.New("goreleaser").Parse(goreleaserTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = fmt.Errorf("closing file: %w", cerr)
		}
	}()

	if err = tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	return nil
}