package main

import (
	"flag"
	"fmt"
	"os"
	"text/template"

	"github.com/rshade/finfocus-plugin-aws-public/internal/regionsconfig"
)

// TemplateData holds the data passed to the GoReleaser template.
type TemplateData struct {
	Regions []regionsconfig.RegionConfig
}

const goreleaserTemplate = `# Generated by tools/generate-goreleaser - DO NOT EDIT MANUALLY
# Regenerate with: make generate-goreleaser

version: 2

builds:
{{- range .Regions}}
  - id: {{.Name}}
    main: ./cmd/finfocus-plugin-aws-public
    binary: finfocus-plugin-aws-public-{{.Name}}
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    tags:
      - {{.Tag}}
    ldflags:
      - -s -w -X main.version={{"{{"}} .Version {{"}}"}}
{{end}}
archives:
  - formats:
      - tar.gz
    name_template: >-
      {{"{{"}} .ProjectName {{"}}"}}_
      {{"{{"}} .Version {{"}}"}}_
      {{"{{"}} title .Os {{"}}"}}_
      {{"{{"}} if eq .Arch "amd64" {{"}}"}}x86_64
      {{"{{"}} else if eq .Arch "386" {{"}}"}}i386
      {{"{{"}} else {{"}}"}}{{"{{"}} .Arch {{"}}"}}{{"{{"}} end {{"}}"}}
      {{"{{"}} if .Arm {{"}}"}}v{{"{{"}} .Arm {{"}}"}}{{"{{"}} end {{"}}"}}
    format_overrides:
      - goos: windows
        formats:
          - zip

checksum:
  name_template: checksums.txt

snapshot:
  name_template: "{{"{{"}} incpatch .Version {{"}}"}}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"
      - "chore:"
      - "Merge pull request"
      - "Merge branch"

source:
  enabled: false
`

// main parses command-line flags, reads and validates a regions YAML file,
// generates a GoReleaser configuration from the regions, and writes it to disk.
//
// It accepts flags `-config` (path to regions YAML, default "regions.yaml")
// and `-output` (output file path, default ".goreleaser.yaml"). The program
// exits with status 1 on errors loading the config, validating regions, or
// generating the output file, and prints a confirmation message on success.
func main() {
	configPath := flag.String("config", "regions.yaml", "Path to regions config")
	outputPath := flag.String("output", ".goreleaser.yaml", "Output file path")
	flag.Parse()

	// Load and validate regions config using shared package (FR-004, FR-005)
	config, err := regionsconfig.LoadAndValidate(*configPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading regions config: %v\n", err)
		os.Exit(1)
	}

	// Generate GoReleaser config
	if err := generateGoReleaserConfig(config.Regions, *outputPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating GoReleaser config: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated GoReleaser config at %s with %d regions\n", *outputPath, len(config.Regions))
}

// generateGoReleaserConfig generates a GoReleaser configuration file at outputPath using the provided regions.
// It fills a TemplateData with the regions, parses the package's goreleaserTemplate, and writes the rendered result
// to the specified output file.
//
// regions is the list of RegionConfig entries to include in the generated configuration.
// outputPath is the filesystem path where the rendered configuration will be created (truncated if existing).
//
// It returns an error if template parsing fails, the output file cannot be created, template execution fails,
// or if closing the output file produces an error.
func generateGoReleaserConfig(regions []regionsconfig.RegionConfig, outputPath string) (err error) {
	data := TemplateData{
		Regions: regions,
	}

	tmpl, err := template.New("goreleaser").Parse(goreleaserTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = fmt.Errorf("closing file: %w", cerr)
		}
	}()

	if err = tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	return nil
}