# Phase 0: Research & Feasibility

## 1. Critical Feasibility: Image Size

**Requirement**: SC-001 targets ~300MB image size.
**Requirement**: FR-004 requires binaries for all 12 regions.
**Constitution**: Each region binary embeds ~150MB of pricing data.

**Findings**:
- `internal/pricing/data/ec2_us-east-1.json` is ~148MB.
- Total pricing data for one region is ~156MB.
- 12 regions Ã— 156MB = **1.87 GB**.
- Alpine base is ~10MB.
- Go binaries (code) are small (~10MB).
- **Total estimated image size**: ~1.9 GB.

**Conclusion**: 
The target of 300MB is **impossible** to achieve while embedding distinct pricing data for 12 regions. 
- **Decision**: Flag as Critical Spec/Constitution Conflict.
- **Recommendation**: 
  1. Revise SC-001 to accept ~2GB image size.
  2. OR Change User Story 1 to use region-specific images (e.g., `finfocus-plugin-aws-public:us-east-1`).

## 2. Metrics Aggregation (FR-019)

**Requirement**: Expose Prometheus metrics on port 9090 with per-region health.
**Context**: 12 independent processes running on ports 8001-8012.

**Findings**:
- `pluginsdk` likely supports `/metrics` if enabled.
- Prometheus scraping expects a single target or multiple targets.
- A "single endpoint on 9090" implies aggregation.

**Options**:
1. **Custom Aggregator**: A small Go tool listening on 9090 that scrapes localhost:8001-8012 and aggregates.
   - *Pros*: Precise control, satisfies "single endpoint".
   - *Cons*: Development effort.
2. **Nginx Reverse Proxy**: Map `/metrics/us-east-1` to `8001`.
   - *Pros*: Standard tool.
   - *Cons*: Adds Nginx size (~20MB) and config complexity. Not a "single aggregated view" (just routed paths).
3. **Expose 12 ports**: Let Prometheus scrape 12 targets.
   - *Pros*: Simplest.
   - *Cons*: Violates FR-019 "endpoint on 9090".

**Decision**: **Custom Aggregator**.
- We will build a small `cmd/metrics-aggregator` tool.
- It will scrape all 12 ports and merge the results, or expose them under federated paths.
- **Rationale**: Keeps image small (Go static binary), meets FR-019 exactly.

## 3. Signal Handling & Entrypoint

**Requirement**: Graceful shutdown (FR-006).

**Findings**:
- PID 1 in Docker must handle signals.
- Bash `trap` can handle SIGTERM but requires care with wait.
- `tini` is the standard init for containers.

**Decision**: Use `tini` as entrypoint, which spawns the `entrypoint.sh` bash script.
- `entrypoint.sh` will start 12 binaries in background (`&`) and `wait`.
- It will install a `trap` to catch SIGTERM, send SIGTERM to all jobs, and wait for them.

## 4. Build Process

**Requirement**: Download 12 tarballs.
**Constraint**: GitHub Actions.

**Decision**:
- `Dockerfile` will accept `VERSION` arg.
- `RUN` step will use `curl` to fetch 12 tarballs from `https://github.com/rshade/finfocus-plugin-aws-public/releases/download/${VERSION}/...`.
- Verification: SHA256 checksums should be used if available (generated by GoReleaser).

